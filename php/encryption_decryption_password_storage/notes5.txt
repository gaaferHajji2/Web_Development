1--> What Is a Hash?
--------------------
First, I need to cover the basics. Hashing is not encryption; passwords should be one-way hashed. This means that it is impossible to decrypt, hence the one-way part of that. There is never a need to display a password back to a user/admin/mother/anyone ever. Once a password is entered, it becomes something totally different, a hash that can be re-created only by the original password being given as input.
	+++++++++++++++++++++++++++++++++++++++++++++++++++
2--> Popular Attacks against Hashing Algorithm:
-----------------------------------------------

a--> Lookup Tables:
-------------------
A lookup table is simply a table of hashes where the password is known. It can be as simple as this:
------------------------
|password | hash	|
------------------------
pass1    | bidfb2enkjnf	|
pass2    | psdfnojn3nod	|
etc...	 |		|
-------------------------
This is then compared against the password hashes in your database to determine the password that was used. This attack is useless if you are using random salts, but it’s easier than robbing a train if the hashes aren’t salted.

b--> Rainbow Tables:
--------------------
A rainbow table is technically sophisticated compared to a lookup table yet very similar. It is basically a less memory-intensive way of achieving a lookup table through mathematic means. You can think of them interchangeably as I mention them here. Rainbow tables are also thwarted through the use of random salts, so they are less relevant with modern hashing algorithms. A rainbow table is a very complex exploit.
(we can read from wikipedia)

c--> Collision Attacks:
-----------------------
A collision attack is the main security flaw found in most hashing algorithms. There are two types of collision attacks.

A classical collision attack is when two different values generate the same hash. A simple example is:
string1 = 'abc123'
string2 = 'bcd234'
hash(string1) === hash(string2)

A chosen-prefix collision attack is when different prefixes are used to cause two separate values to generate the same hash. Here is an example of this :
prefix1 = 'zxy'
prefix2 = 'abc'
string1 = 'abc123'
string2 = 'bcd234'
hash(prefix1 + string1) === hash(prefix2 + string2)

--here we can show the important of use prime number for hasing keywords, files, ...etc.

d--> A Pinch of Salt:
---------------------
That’s not enough though. The next problems to look out for are lookup table and rainbow table exploits. Both of these exploits basically keep a list of popular passwords and their resulting hashes. Rainbow tables are a little more complex, but that’s basically what’s going on. How do we combat this? Salts. RANDOM SALTS. A salt is something that is appended to the password hash to make it unique. Salt is also something that is added to the rim of a margarita to make it delicious. Ah margaritas. Anyway. So you take a random string (salt) and combine it with the plain-text password string to give you a unique value. This means that even with a lookup table of known password hashes an attacker can’t match up your user’s password hash with the database password hashes since a random salt has been used. Given two identical passwords, the resulting hashes will be unique. A random salt is one of the most important pieces of your password security.

e--> Random Isn’t Always Random:
--------------------------------
You’re salt needs to be random to be effective. Random !== random though. You don’t necessarily need truly random numbers but rand() won’t cut it either. The problem with using PHP’s built-in rand() and mt_rand() functions is that they are seeded with data that can be manipulated and determined; they don’t provide enough “randomness.” The main ingredient needed to produce a truly random number is to include enough entropy into the source. Entropy is the amount of truly random information collected by the system that is generating your random number. Most noncryptographic random number generators, like rand() and mt_rand() , use algorithms to produce their numbers without enough outside sources of data to make them truly unique.

This means that the data rand() produces can be manipulated and guessed by an attacker. After observing enough of the output of rand() an attacker can reliably determine the future output. In fact after returning as few as 624 values from rand() it is possible to calculate all future values.

You have been warned, you SHOULD NOT use rand() for your salts(but we can change the seed and save it in the profile of the user and generate secure key that we can sent it in the email). In the face with a first-generation iPad if you use rand() for your salts. That thing was solid as a brick. Calling your server’s /dev/random is your best bet for true random on most systems. The issue with using this for log in is that it blocks execution while collecting entropy from the system. Collecting entropy means that it will collect environmental data from your system, such as various hardware data, keyboard typing, mouse movements, disk access, etc., in order to generate a buffer of random bits. This means that it can take a long time to return, especially on servers that aren’t busy. I actually ran into this problem recently. A developer on my team used /dev/random to generate an activation code. Everything seemed fine, it passed testing fine. Then after we deployed the project to its own production server, requests ended up taking over 60 seconds. The server wasn’t busy because it was only hosting this one
project, causing /dev/random to block for a good bit of time while it collected entropy. What was the solution?
/dev/urandom

The pseudorandom number generator /dev/urandom isn’t considered true random, but it is cryptographically secure. This means that it might not be a truly random number, but it is regarded as secure enough for use in salts. It will return a very good pseudorandom number immediately with no blocking; and it uses the existing entropy pool to generate a pseudorandom number that is secure enough for the majority of authentication systems. If you’re writing the login page for nuclear launch codes, it might be best to make the user wait on /dev/random , but for that social picture sharing site, /dev/urandom is good enough.
	+++++++++++++++++++++++++++++++++++++++++++++++++++
3--> Hashing Algorithms:
------------------------

a--> MD5:
----------
I see the MD5 hashing algorithm used incorrectly more often than anything else, usually because it is supported by most databases by default. MD5 has been mathematically proven for some time now to be insecure. The issue with MD5 is that it is trivially easy to produce collisions on modern hardware.

One of the most notable examples, in 2005 researchers were able to generate collisions in MD5 checksums using a laptop. 5 The significance of that is that it doesn’t take a $200k beast of a server to break MD5, just any old laptop, and that was in 2005. In 2005 people, that was like 100 Internet years ago. No more MD5 for password hashing, please. Nonsecure hashes to verify data contents, sure. Just not for secure hashes that an attacker would be interested in breaking.

MD5 is not completely broken because it is still mostly secure when used with a proper salt. That doesn’t mean that you shouldn’t move on to a more future-proven solution though.
